from enum import StrEnum
from pathlib import Path
from dataclasses import field, dataclass

from _typeshed import Incomplete
from ataraxis_data_structures import YamlConfig

from .configuration_data import (
    AcquisitionSystems as AcquisitionSystems,
    get_system_configuration_data as get_system_configuration_data,
)
from ..tools.transfer_tools import delete_directory as delete_directory

class SessionTypes(StrEnum):
    """Stores the data acquisition session types supported by all data acquisition systems used in the Sun lab.

    A data acquisition session is typically carried out to acquire experiment data, train the animal for the upcoming
    experiment sessions, or to assess the quality of surgical or other pre-experiment interventions. After acquisition,
    the session is treated as a uniform package whose components can be accessed via the SessionData class.

    Notes:
        Different acquisition systems support different session types and may not be suited for acquiring some of the
        session types listed in this enumeration.
    """

    LICK_TRAINING = "lick training"
    RUN_TRAINING = "run training"
    MESOSCOPE_EXPERIMENT = "mesoscope experiment"
    WINDOW_CHECKING = "window checking"

@dataclass()
class RawData:
    """Stores the paths to the directories and files that make up the 'raw_data' session-specific directory.

    The raw_data directory stores the data acquired during the session data acquisition runtime, before and after
    preprocessing. Since preprocessing does not irreversibly alter the data, any data in that folder is considered
    'raw,' event if preprocessing losslessly re-compresses the data for efficient transfer.

    Notes:
        Sun lab data management strategy primarily relies on keeping multiple redundant copies of the raw_data for
        each acquired session. Typically, one copy is stored on the lab's processing server and the other is stored on
        the NAS.
    """

    raw_data_path: Path = ...
    camera_data_path: Path = ...
    mesoscope_data_path: Path = ...
    behavior_data_path: Path = ...
    zaber_positions_path: Path = ...
    session_descriptor_path: Path = ...
    hardware_state_path: Path = ...
    surgery_metadata_path: Path = ...
    session_data_path: Path = ...
    experiment_configuration_path: Path = ...
    mesoscope_positions_path: Path = ...
    window_screenshot_path: Path = ...
    system_configuration_path: Path = ...
    checksum_path: Path = ...
    telomere_path: Path = ...
    ubiquitin_path: Path = ...
    nk_path: Path = ...
    root_path: Path = ...
    def resolve_paths(self, root_directory_path: Path) -> None:
        """Resolves all paths managed by the class instance based on the input root directory path.

        This method is called each time the (wrapper) SessionData class is instantiated to regenerate the managed path
        hierarchy on any machine that instantiates the class.

        Args:
            root_directory_path: The path to the top-level directory of the session. Typically, this path is assembled
                using the following hierarchy: root/project/animal/session_id
        """
    def make_directories(self) -> None:
        """Ensures that all major subdirectories and the root directory exist, creating any missing directories.

        This method is called each time the (wrapper) SessionData class is instantiated and allowed to generate
        missing data directories.
        """

@dataclass()
class ProcessedData:
    """Stores the paths to the directories and files that make up the 'processed_data' session-specific directory.

    The processed_data directory stores the data generated by various processing pipelines from the raw data (contents
    of the raw_data directory). Processed data represents an intermediate step between raw data and the dataset used in
    the data analysis, but is not itself designed to be analyzed.
    """

    processed_data_path: Path = ...
    camera_data_path: Path = ...
    mesoscope_data_path: Path = ...
    behavior_data_path: Path = ...
    root_path: Path = ...
    def resolve_paths(self, root_directory_path: Path) -> None:
        """Resolves all paths managed by the class instance based on the input root directory path.

        This method is called each time the (wrapper) SessionData class is instantiated to regenerate the managed path
        hierarchy on any machine that instantiates the class.

        Args:
            root_directory_path: The path to the top-level directory of the session. Typically, this path is assembled
                using the following hierarchy: root/project/animal/session_id
        """
    def make_directories(self) -> None:
        """Ensures that all major subdirectories and the root directory exist, creating any missing directories.

        This method is called each time the (wrapper) SessionData class is instantiated and allowed to generate
        missing data directories.
        """

@dataclass()
class TrackingData:
    """Stores the paths to the directories and files that make up the 'tracking_data' session-specific directory.

    This directory was added in version 5.0.0 to store the ProcessingTracker files and .lock files for pipelines and
    tasks used to work with session's data after acquisition.
    """

    tracking_data_path: Path = ...
    session_lock_path: Path = ...
    def resolve_paths(self, root_directory_path: Path) -> None:
        """Resolves all paths managed by the class instance based on the input root directory path.

        This method is called each time the (wrapper) SessionData class is instantiated to regenerate the managed path
        hierarchy on any machine that instantiates the class.

        Args:
            root_directory_path: The path to the top-level directory of the session. Typically, this path is assembled
                using the following hierarchy: root/project/animal/session_id
        """
    def make_directories(self) -> None:
        """Ensures that all major subdirectories and the root directory exist, creating any missing directories.

        This method is called each time the (wrapper) SessionData class is instantiated and allowed to generate
        missing data directories.
        """

@dataclass
class SessionData(YamlConfig):
    """Stores and manages the data layout of a single Sun lab data acquisition session.

    The primary purpose of this class is to maintain the session data structure across all supported destinations
    and to provide a unified data access interface shared by all Sun lab libraries. It is specifically designed for
    working with the data from a single session, performed by a single animal under the specific project. The class is
    used to manage both raw and processed data: it follows the data through acquisition, preprocessing, and processing
    stages of the Sun lab data workflow. This class serves as an entry point for all interactions with the managed
    session's data.

    Notes:
        The class is not designed to be instantiated directly. Instead, use the create() method to generate a new
        session or load() method to access the data of an already existing session.

        When the class is used to create a new session, it generates the new session's name using the current UTC
        timestamp, accurate to microseconds. This ensures that each session 'name' is unique and preserves the overall
        session order.
    """

    project_name: str
    animal_id: str
    session_name: str
    session_type: str | SessionTypes
    acquisition_system: str | AcquisitionSystems = ...
    experiment_name: str | None = ...
    python_version: str = ...
    sl_experiment_version: str = ...
    raw_data: RawData = field(default_factory=Incomplete)
    processed_data: ProcessedData = field(default_factory=Incomplete)
    source_data: RawData = field(default_factory=Incomplete)
    archived_data: ProcessedData = field(default_factory=Incomplete)
    tracking_data: TrackingData = field(default_factory=Incomplete)
    def __post_init__(self) -> None:
        """Ensures raw_data, processed_data, and source_data are always instances of RawData and ProcessedData."""
    @classmethod
    def create(
        cls,
        project_name: str,
        animal_id: str,
        session_type: SessionTypes | str,
        python_version: str,
        sl_experiment_version: str,
        experiment_name: str | None = None,
        session_name: str | None = None,
    ) -> SessionData:
        """Creates a new SessionData object and generates the new session's data structure on the local PC.

        This method is intended to be called exclusively by the sl-experiment library to create new training or
        experiment sessions and generate the session data directory tree.

        Notes:
            To load an already existing session data structure, use the load() method instead.

            This method automatically dumps the data of the created SessionData instance into the session_data.yaml file
            inside the root 'raw_data' directory of the created hierarchy. It also finds and dumps other configuration
            files, such as experiment_configuration.yaml and system_configuration.yaml into the same 'raw_data'
            directory. If the session's runtime is interrupted unexpectedly, the acquired data can still be processed
            using these pre-saved class instances.

        Args:
            project_name: The name of the project for which the session is carried out.
            animal_id: The ID code of the animal participating in the session.
            session_type: The type of the session. Has to be one of the supported session types exposed by the
                SessionTypes enumeration.
            python_version: The string that specifies the Python version used to collect session data. Has to be
                specified using the major.minor.patch version format.
            sl_experiment_version: The string that specifies the version of the sl-experiment library used to collect
                session data. Has to be specified using the major.minor.patch version format.
            experiment_name: The name of the experiment executed during the session. This optional argument is only
                used for experiment sessions. Note! The name passed to this argument has to match the name of the
                experiment configuration .yaml file.
            session_name: An optional session name override. Generally, this argument should not be provided for most
                sessions. When provided, the method uses this name instead of generating a new timestamp-based name.
                This is only used during the 'ascension' runtime to convert old data structures to the modern
                lab standards.

        Returns:
            An initialized SessionData instance that stores the layout of the newly created session's data.
        """
    @classmethod
    def load(cls, session_path: Path, processed_data_root: Path | None = None) -> SessionData:
        """Loads the SessionData instance from the target session's session_data.yaml file.

        This method is used to load the data layout information of an already existing session. Primarily, this is used
        when processing session data. Due to how SessionData is stored and used in the lab, this method always loads the
        data layout from the session_data.yaml file stored inside the 'raw_data' session subfolder. Currently, all
        interactions with Sun lab data require access to the 'raw_data' folder of each session.

        Notes:
            To create a new session, use the create() method instead.

        Args:
            session_path: The path to the root directory of an existing session, e.g.: root/project/animal/session.
            processed_data_root: If processed data is kept on a drive different from the one that stores raw data,
                provide the path to the root project directory (directory that stores all Sun lab projects) on that
                drive. The method will automatically resolve the project/animal/session/processed_data hierarchy using
                this root path. If raw and processed data are kept on the same drive, keep this set to None.

        Returns:
            An initialized SessionData instance for the session whose data is stored at the provided path.

        Raises:
            FileNotFoundError: If multiple or no 'session_data.yaml' file instances are found under the input session
                path directory.

        """
    def runtime_initialized(self) -> None:
        """Ensures that the 'nk.bin' marker file is removed from the session's raw_data folder.

        The 'nk.bin' marker is generated as part of the SessionData initialization (creation) process to mark sessions
        that did not fully initialize during runtime. This service method is designed to be called by the sl-experiment
        library classes to remove the 'nk.bin' marker when it is safe to do so. It should not be called by end-users.
        """
    def save(self) -> None:
        """Saves the instance data to the 'raw_data' directory of the managed session as a 'session_data.yaml' file.

        This is used to save the data stored in the instance to disk so that it can be reused during further stages of
        data processing. The method is intended to only be used by the SessionData instance itself during its
        create() method runtime.
        """

@dataclass()
class SessionLock(YamlConfig):
    """Provides thread-safe session locking to ensure exclusive access during data processing.

    This class manages a lock file that tracks which manager process currently has exclusive access to a data
    acquisition session's data. It prevents race conditions when multiple manager processes attempt to modify session
    data simultaneously. Primarily, this class is used on remote compute server(s).

    Notes:
        The lock owner is identified by a manager process ID, allowing distributed processing across
        multiple jobs while maintaining data integrity.
    """

    file_path: Path
    _manager_id: int = ...
    _lock_path: str = field(init=False)
    def __post_init__(self) -> None:
        """Initializes the lock file path based on the .yaml file path."""
    def _load_state(self) -> None:
        """Loads the current lock state from the .yaml file."""
    def _save_state(self) -> None:
        """Saves the current lock state to the .yaml file."""
    def acquire(self, manager_id: int) -> None:
        """Acquires the session access lock.

        Args:
            manager_id: The unique identifier of the manager process requesting the lock.

        Raises:
            TimeoutError: If the .lock file cannot be acquired for a long period of time due to being held by another
                process.
            RuntimeError: If the lock is held by another process and forcing lock acquisition is disabled.
        """
    def release(self, manager_id: int) -> None:
        """Releases the session access lock.

        Args:
            manager_id: The unique identifier of the manager process releasing the lock.

        Raises:
            TimeoutError: If the .lock file cannot be acquired for a long period of time due to being held by another
                process.
            RuntimeError: If the lock is held by another process.
        """
    def force_release(self) -> None:
        """Forcibly releases the session access lock regardless of ownership.

        This method should only be used for emergency recovery from improper processing shutdowns. It can be called by
        any process to unlock any session, but it does not attempt to terminate the processes that the lock's owner
        might have deployed to work with the session's data.

        Raises:
            TimeoutError: If the .lock file cannot be acquired for a long period of time due to being held by another
                process.
        """
    def check_owner(self, manager_id: int) -> None:
        """Ensures that the managed session is locked for processing by the specified manager process.

        This method is used by worker functions to ensure it is safe to interact with the session's data. It is designed
        to abort the runtime with an error if the session's lock file is owned by a different manager process.

        Args:
            manager_id: The unique identifier of the manager process attempting to access the session's data.

        Raises:
            TimeoutError: If the .lock file cannot be acquired for a long period of time due to being held by another
                process.
            ValueError: If the lock file is held by a different manager process.
        """
