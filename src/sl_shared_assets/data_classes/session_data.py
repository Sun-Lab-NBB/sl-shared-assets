"""This module contains classes jointly responsible for maintaining the Sun lab project data hierarchy across all
machines used to acquire, process, and store the data. Every valid experiment or training session conducted in the
lab generates a specific directory structure. This structure is defined via the ProjectConfiguration and SessionData
classes, which are also stored as .yaml files inside each session's raw_data and processed_data directories. Jointly,
these classes contain all necessary information to restore the data hierarchy on any machine. All other Sun lab
libraries use these classes to work with all lab-generated data."""

import re
import copy
import shutil as sh
from pathlib import Path
from dataclasses import field, dataclass

from .configuration_data import MesoscopeSystemConfiguration
from ataraxis_base_utilities import LogLevel, console, ensure_directory_exists
from ataraxis_data_structures import YamlConfig
from ataraxis_time.time_helpers import get_timestamp


@dataclass()
class ProjectConfiguration(YamlConfig):
    """Stores the project-specific configuration parameters that do not change between different animals and runtime
    sessions.

    An instance of this class is generated and saved as a .yaml file in the 'configuration' directory of each project
    when it is created. After that, the stored data is reused for every runtime (training or experiment session) carried
    out for each animal of the project. Additionally, a copy of the most actual configuration file is saved inside each
    runtime session's 'raw_data' folder, providing seamless integration between the managed data and various Sun lab
    (sl-) libraries.

    Notes:
        Together with SessionData, this class forms the entry point for all interactions with the data acquired in the
        Sun lab. The fields of this class are used to flexibly configure the runtime behavior of major data acquisition
        (sl-experiment) and processing (sl-forgery) libraries, adapting them for any project in the lab.
    """

    project_name: str = ""
    """Stores the descriptive name of the project. This name is used to create the root directory for the project and 
    to initialize SessionData instances each time any Sun lab library interacts with the session's data."""
    surgery_sheet_id: str = ""
    """The ID of the Google Sheet file that stores information about surgical interventions performed on all animals 
    participating in the managed project. This log sheet is used to parse and write the surgical intervention data for 
    each animal into every runtime session raw_data folder, so that the surgery data is always kept together with the 
    rest of the training and experiment data."""
    water_log_sheet_id: str = ""
    """The ID of the Google Sheet file that stores information about water restriction (and behavior tracker) 
    information for all animals participating in the managed project. This is used to synchronize the information 
    inside the water restriction log with the state of the animal at the end of each training or experiment session.
    """

    @classmethod
    def load(cls, configuration_path: Path) -> "ProjectConfiguration":
        """Loads the project configuration parameters from the specified project_configuration.yaml file.

        This method is called during each interaction with any runtime session's data, including the creation of a new
        session. Note, this method always assumes that the configuration file specified by the 'configuration_path'
        argument exists and was generated by the ProjectConfiguration instance.

        Args:
            configuration_path: The path to the project_configuration.yaml file from which to load the data.

        Returns:
            The initialized ProjectConfiguration instance that stores the configuration data for the target project.
        """

        # Prevents loading non-existent files.
        if configuration_path.suffix != ".yaml" or not configuration_path.exists():
            message = (
                f"Unable to load the project configuration data from the specified path: {configuration_path}. Valid "
                f"configuration file paths should use the '.yaml' extension and point to an existing file."
            )
            console.error(message=message, error=FileNotFoundError)

        # Loads the data from the YAML file and initializes the class instance.
        instance: ProjectConfiguration = cls.from_yaml(file_path=configuration_path)  # type: ignore

        # Verifies the loaded data. Most importantly, this step does not allow proceeding if the user did not
        # replace the surgery log and water restriction log placeholders with valid ID values.
        instance._verify_data()

        # Returns the initialized class instance to caller
        return instance

    def save(self, path: Path) -> None:
        """Saves class instance data to disk as a project_configuration.yaml file.

        This method is automatically called from the 'sl_experiment' library when a new project is created. After this
        method's runtime, all future project initialization calls will use the load() method to reuse configuration data
        saved to the .yaml file created by this method.

        Args:
            path: The path to the .yaml file to save the data to.
        """

        # Saves the data to the YAML file
        self.to_yaml(file_path=path)

    def _verify_data(self) -> None:
        """Verifies the user-modified data loaded from the project_configuration.yaml file.

        Since this class is explicitly designed to be modified by the user, this verification step is carried out to
        ensure that the loaded data matches expectations. This reduces the potential for user errors to impact the
        runtime behavior of the libraries using this class. This internal method is automatically called by the load()
        method.

        Raises:
            ValueError: If the loaded data does not match expected formats or values.
        """

        # Verifies Google Sheet ID formatting. Google Sheet IDs are usually 44 characters long, containing letters,
        # numbers, hyphens, and underscores
        pattern = r"^[a-zA-Z0-9_-]{44}$"
        if not re.match(pattern, self.surgery_sheet_id):
            message = (
                f"Unable to verify the surgery_sheet_id field loaded from the 'project_configuration.yaml' file. "
                f"Expected a string with 44 characters, using letters, numbers, hyphens, and underscores, but found: "
                f"{self.surgery_sheet_id}."
            )
            console.error(message=message, error=ValueError)
        if not re.match(pattern, self.water_log_sheet_id):
            message = (
                f"Unable to verify the surgery_sheet_id field loaded from the 'project_configuration.yaml' file. "
                f"Expected a string with 44 characters, using letters, numbers, hyphens, and underscores, but found: "
                f"{self.water_log_sheet_id}."
            )
            console.error(message=message, error=ValueError)


@dataclass()
class RawData:
    """Stores the paths to the directories and files that make up the 'raw_data' session-specific directory.

    The raw_data directory stores the data acquired during the session runtime before and after preprocessing. Since
    preprocessing does not alter the data, any data in that folder is considered 'raw'.

    Notes:
        Sun lab data management strategy primarily relies on keeping multiple redundant copies of the raw_data for
        each acquired session. Typically, one copy is stored on the lab's processing server and the other is stored on
        the NAS.
    """

    raw_data_path: Path = Path()
    """Stores the path to the root raw_data directory of the session. This directory stores all raw data during 
    acquisition and preprocessing. Note, preprocessing does not alter raw data, so at any point in time all data inside
    the folder is considered 'raw'."""
    camera_data_path: Path = Path()
    """Stores the path to the directory that contains all camera data acquired during the session. Primarily, this 
    includes .mp4 video files from each recorded camera."""
    mesoscope_data_path: Path = Path()
    """Stores the path to the directory that contains all Mesoscope data acquired during the session. Primarily, this 
    includes the mesoscope-acquired .tiff files (brain activity data) and the motion estimation data. This directory is
    only used by the sessions that use the Mesoscope-VR system. Otherwise, the directory will be created, but will be 
    empty."""
    behavior_data_path: Path = Path()
    """Stores the path to the directory that contains all non-video behavior data acquired during the session. 
    Primarily, this includes the .npz log files that store serialized data acquired by all hardware components of the 
    data acquisition system other than cameras and brain activity data acquisition devices (such as the Mesoscope)."""
    zaber_positions_path: Path = Path()
    """Stores the path to the zaber_positions.yaml file. This file contains the snapshot of all Zaber motor positions 
    at the end of the session. Zaber motors are used to position the LickPort and the HeadBar manipulators, which is 
    essential for supporting proper brain imaging and animal's running behavior during the session. This file is only 
    created for sessions that use the Mesoscope=VR system."""
    session_descriptor_path: Path = Path()
    """Stores the path to the session_descriptor.yaml file. This file is partially filled by the system during runtime 
    and partially by the experimenter after the runtime. It contains session-specific information, such as the specific
    task parameters and the notes made by the experimenter during runtime."""
    hardware_state_path: Path = Path()
    """Stores the path to the hardware_state.yaml file. This file contains the partial snapshot of the calibration 
    parameters used by the data acquisition and runtime management system components during the session. Primarily, 
    this is used during data processing to read the .npz data log files generated during runtime."""
    surgery_metadata_path: Path = Path()
    """Stores the path to the surgery_metadata.yaml file. This file contains the most actual information about the 
    surgical intervention(s) performed on the animal prior to the session."""
    project_configuration_path: Path = Path()
    """Stores the path to the project_configuration.yaml file. This file contains the snapshot of the configuration 
    parameters for the session's project."""
    session_data_path: Path = Path()
    """Stores the path to the session_data.yaml file. This path is used by the SessionData instance to save itself to 
    disk as a .yaml file. The file contains the paths to all raw and processed data directories used during data 
    acquisition or processing runtime."""
    experiment_configuration_path: Path = Path()
    """Stores the path to the experiment_configuration.yaml file. This file contains the snapshot of the 
    experiment runtime configuration used by the session. This file is only created for experiment session. It is not
    created for behavior training sessions."""
    mesoscope_positions_path: Path = Path()
    """Stores the path to the mesoscope_positions.yaml file. This file contains the snapshot of the positions used
    by the Mesoscope at the end of the session. This includes both the physical position of the mesoscope objective and
    the 'virtual' tip, tilt, and fastZ positions set via ScanImage software. This file is only created for experiment 
    sessions that use the Mesoscope-VR system."""
    window_screenshot_path: Path = Path()
    """Stores the path to the .png screenshot of the ScanImagePC screen. The screenshot should contain the image of the 
    cranial window and the red-dot alignment windows. This is used to generate a visual snapshot of the cranial window
    alignment and appearance for each experiment session. This file is only created for sessions that use the 
    Mesoscope-VR system."""
    checksum_path: Path = Path()
    """Stores the path to the ax_checksum.txt file. This file is generated as part of packaging the data for 
    transmission and stores the xxHash-128 checksum of the data. It is used to verify that the transmission did not 
    damage or otherwise alter the data."""
    system_configuration_path: Path = Path()
    """Stores the path to the system_configuration.yaml file. This file contains the expanded snapshot of the data 
    acquisition and runtime management system configuration used by the session. Some data from this file is used during
    runtime to generate the HardwareState class, so there is some overlap between these two files."""

    def resolve_paths(self, root_directory_path: Path) -> None:
        """Resolves all paths managed by the class instance based on the input root directory path.

        This method is called each time the class is instantiated to regenerate the managed path hierarchy on any
        machine that instantiates the class.

        Args:
            root_directory_path: The path to the top-level directory of the local hierarchy. Depending on the managed
                hierarchy, this has to point to a directory under the main /session, /animal, or /project directory of
                the managed session.
        """

        # Generates the managed paths
        self.raw_data_path = root_directory_path
        self.camera_data_path = self.raw_data_path.joinpath("camera_data")
        self.mesoscope_data_path = self.raw_data_path.joinpath("mesoscope_data")
        self.behavior_data_path = self.raw_data_path.joinpath("behavior_data")
        self.zaber_positions_path = self.raw_data_path.joinpath("zaber_positions.yaml")
        self.session_descriptor_path = self.raw_data_path.joinpath("session_descriptor.yaml")
        self.hardware_state_path = self.raw_data_path.joinpath("hardware_state.yaml")
        self.surgery_metadata_path = self.raw_data_path.joinpath("surgery_metadata.yaml")
        self.project_configuration_path = self.raw_data_path.joinpath("project_configuration.yaml")
        self.session_data_path = self.raw_data_path.joinpath("session_data.yaml")
        self.experiment_configuration_path = self.raw_data_path.joinpath("experiment_configuration.yaml")
        self.mesoscope_positions_path = self.raw_data_path.joinpath("mesoscope_positions.yaml")
        self.window_screenshot_path = self.raw_data_path.joinpath("window_screenshot.png")
        self.checksum_path = self.raw_data_path.joinpath("ax_checksum.txt")
        self.system_configuration_path = self.raw_data_path.joinpath("system_configuration.yaml")

    def make_directories(self) -> None:
        """Ensures that all major subdirectories and the root directory exist."""
        ensure_directory_exists(self.raw_data_path)
        ensure_directory_exists(self.camera_data_path)
        ensure_directory_exists(self.mesoscope_data_path)
        ensure_directory_exists(self.behavior_data_path)


@dataclass()
class ProcessedData:
    """Stores the paths to the directories and files that make up the 'processed_data' session-specific directory.

    The processed_data directory stores the data generated by various processing pipelines from the raw data (contents
    of the raw_data directory). Processed data represents an intermediate step between raw data and the dataset used in
    the data analysis, but is not itself designed to be analyzed.
    """

    processed_data_path: Path = Path()
    """Stores the path to the root processed_data directory of the session. This directory stores the processed data 
    as it is generated by various data processing pipelines."""
    camera_data_path: Path = Path()
    """Stores the path to the directory that contains video tracking data generated by our DeepLabCut-based video 
    processing pipelines."""
    mesoscope_data_path: Path = Path()
    """Stores path to the directory that contains processed brain activity (cell) data generated by our suite2p-based 
    photometry processing pipelines (single-day and multi-day). This directory is only used by sessions acquired with 
    the Mesoscope-VR system. For all other sessions, it will be created, but kept empty."""
    behavior_data_path: Path = Path()
    """Stores the path to the directory that contains the non-video and non-brain-activity data extracted from 
    .npz log files by our in-house log parsing pipeline."""
    job_logs_path: Path = Path()
    """Stores the path to the directory that stores the standard output and standard error data collected during 
    server-side data processing pipeline runtimes. This directory is primarily used when running data processing jobs 
    on the remote server. However, it is possible to configure local runtimes to also redirect log data to files 
    stored in this directory (by editing ataraxis-base-utilities 'console' variable)."""
    project_configuration_path: Path = Path()
    """Stores the path to the project_configuration.yaml file. This file contains the snapshot of the configuration 
    parameters for the session's project."""
    session_data_path: Path = Path()
    """Stores the path to the session_data.yaml file. This path is used by the SessionData instance to save itself to 
    disk as a .yaml file. The file contains the paths to all raw and processed data directories used during data 
    acquisition or processing runtime."""

    def resolve_paths(self, root_directory_path: Path) -> None:
        """Resolves all paths managed by the class instance based on the input root directory path.

        This method is called each time the class is instantiated to regenerate the managed path hierarchy on any
        machine that instantiates the class.

        Args:
            root_directory_path: The path to the top-level directory of the local hierarchy. Depending on the managed
                hierarchy, this has to point to a directory under the main /session, /animal, or /project directory of
                the managed session.
        """
        # Generates the managed paths
        self.processed_data_path = root_directory_path
        self.camera_data_path = self.processed_data_path.joinpath("camera_data")
        self.mesoscope_data_path = self.processed_data_path.joinpath("mesoscope_data")
        self.behavior_data_path = self.processed_data_path.joinpath("behavior_data")
        self.job_logs_path = self.processed_data_path.joinpath("job_logs")
        self.project_configuration_path = self.processed_data_path.joinpath("project_configuration.yaml")
        self.session_data_path = self.processed_data_path.joinpath("session_data.yaml")

    def make_directories(self) -> None:
        """Ensures that all major subdirectories and the root directory exist."""

        ensure_directory_exists(self.processed_data_path)
        ensure_directory_exists(self.camera_data_path)
        ensure_directory_exists(self.behavior_data_path)
        ensure_directory_exists(self.job_logs_path)


@dataclass
class SessionData(YamlConfig):
    """Stores and manages the data layout of a single training or experiment session acquired using the Sun lab
    Mesoscope-VR system.

    The primary purpose of this class is to maintain the session data structure across all supported destinations and
    during all processing stages. It generates the paths used by all other classes from all Sun lab libraries that
    interact with the session's data from the point of its creation and until the data is integrated into an
    analysis dataset.

    When necessary, the class can be used to either generate a new session or load the layout of an already existing
    session. When the class is used to create a new session, it generates the new session's name using the current
    UTC timestamp, accurate to microseconds. This ensures that each session name is unique and preserves the overall
    session order.

    Notes:
        If this class is instantiated on the VRPC, it is expected that the BioHPC server, Synology NAS, and ScanImagePC
        data directories are mounted on the local filesystem via the SMB or equivalent protocol. All manipulations
        with these destinations are carried out with the assumption that the local OS has full access to these
        directories and filesystems.

        This class is specifically designed for working with the data from a single session, performed by a single
        animal under the specific experiment. The class is used to manage both raw and processed data. It follows the
        data through acquisition, preprocessing and processing stages of the Sun lab data workflow. Together with
        ProjectConfiguration class, this class serves as an entry point for all interactions with the managed session's
        data.
    """

    project_name: str
    """Stores the name of the managed session's project."""
    animal_id: str
    """Stores the unique identifier of the animal that participates in the managed session."""
    session_name: str
    """Stores the name (timestamp-based ID) of the managed session."""
    session_type: str
    """Stores the type of the session. Primarily, this determines how to read the session_descriptor.yaml file. Has 
    to be set to one of the four supported types: 'Lick training', 'Run training', 'Window checking' or 
    'Mesoscope experiment'.
    """
    experiment_name: str | None
    """Stores the name of the experiment configuration file. If the session_type field is set to 'Experiment' and this 
    field is not None (null), it communicates the specific experiment configuration used by the session. During runtime,
    the name stored here is used to load the specific experiment configuration data stored in a .yaml file with the 
    same name. If the session is not an experiment session, this field is ignored."""
    acquisition_system = "Mesoscope"
    """Stores the name of the data acquisition and runtime management system that acquired the data. Since each system
    represents a unique collection of hardware and software in the lab, this precisely identifies how the data was 
    acquired."""
    raw_data: RawData = field(default_factory=lambda: RawData())
    """Stores the paths to all subfolders and files found under the /project/animal/session/raw_data directory of any 
    PC used to work with Sun lab data."""
    processed_data: ProcessedData = field(default_factory=lambda: ProcessedData())
    """Stores the paths to all subfolders and files found under the /project/animal/session/processed_data directory of 
    any PC used to work with Sun lab data."""

    @classmethod
    def create(
        cls,
        project_name: str,
        animal_id: str,
        session_type: str,
        acquisition_system: str,
        experiment_name: str | None = None,
        session_name: str | None = None
    ) -> "SessionData":
        """Creates a new SessionData object and generates the new session's data structure on the local PC.

        This method is primarily called by sl-experiment runtimes that create new training or experiment sessions to
        generate the session data directory tree. Depending on configuration, the method

        Notes:
            To load an already existing session data structure, use the load() method instead.

            This method automatically dumps the data of the created SessionData instance into the session_data.yaml file
            inside the root raw_data directory of the created hierarchy. It also finds and dumps other configuration
            files, such as project_configuration.yaml and experiment_configuration.yaml, into the same raw_data
            directory. This ensures that if the session's runtime is interrupted unexpectedly, the acquired data can
            still be processed.

        Args:
            project_name: The name of the project for which the data is acquired.
            animal_id: The ID code of the animal for which the data is acquired.
            session_type: The type of the session. Primarily, this determines how to read the session_descriptor.yaml
                file. Valid options are 'Lick training', 'Run training', 'Window checking', or 'Experiment'.
            acquisition_system: The ID of the data acquisition and runtime management system that acquired the data.
                Currently, the only valid option is 'Mesoscope'.
            experiment_name: The name of the experiment executed during managed session. This optional argument is only
                used for 'Experiment' session types. It is used to find the experiment configuration .YAML file.
            session_name: An optional session_name override. Generally, this argument should not be provided for most
                sessions. When provided, the method uses this name instead of generating a new timestamp-based name.
                This is only used during the 'ascension' runtime to convert old data structures to the modern
                lab standards.

        Returns:
            An initialized SessionData instance that stores the layout of the newly created session's data.
        """

        # Acquires the UTC timestamp to use as the session name
        if session_name is None:
            session_name = str(get_timestamp(time_separator="-"))

        # Resolves tha acquisition system configuration.
        if acquisition_system == "Mesoscope":
            acquisition_system = MesoscopeSystemConfiguration.load()
        else:
            message = (
                f"Unsupported acquisition system' {acquisition_system}' encountered when creating SessionData instance "
                f"for session {session_name} of animal {animal_id} and project {project_name}. Currently, only the "
                f"'Mesoscope' acquisition system is supported."
            )
            console.error(message=message, error=ValueError)

        # Constructs the session directory path
        session_path = acquisition_system.root_directory.joinpath(project_name, animal_id, session_name)

        # Handles potential session name conflicts
        counter = 0
        while session_path.exists():
            counter += 1
            new_session_name = f"{session_name}_{counter}"
            session_path = acquisition_system.root_directory.joinpath(project_name, animal_id, new_session_name)

        # If a conflict is detected and resolved, warns the user about the resolved conflict.
        if counter > 0:
            message = (
                f"Session name conflict occurred for animal '{animal_id}' of project '{project_name}' "
                f"when adding the new session with timestamp {session_name}. The session with identical name "
                f"already exists. The newly created session directory uses a '_{counter}' postfix to distinguish "
                f"itself from the already existing session directory."
            )
            console.echo(message=message, level=LogLevel.ERROR)

        # Generates subclasses stored inside the main class instance based on the data resolved above. Note; most fields
        # of these classes are resolved automatically, based on one or more 'root' paths provided to the 'resolve_paths'
        # method.
        raw_data = RawData()
        raw_data.resolve_paths(root_directory_path=session_path.joinpath("raw_data"))
        raw_data.make_directories()  # Generates the local directory tree

        processed_data = ProcessedData()
        processed_data.resolve_paths(root_directory_path=session_path.joinpath("processed_data"))
        processed_data.make_directories()

        # Packages the sections generated above into a SessionData instance
        instance = SessionData(
            project_name=project_name,
            animal_id=animal_id,
            session_name=session_name,
            session_type=session_type,
            raw_data=raw_data,
            processed_data=processed_data,
            experiment_name=experiment_name,
        )

        # Saves the configured instance data to the session's folder, so that it can be reused during processing or
        # preprocessing
        instance._save()

        # Returns the initialized SessionData instance to caller
        return instance

    @classmethod
    def load(
        cls,
        session_path: Path,
        on_server: bool,
        make_directories: bool = True,
    ) -> "SessionData":
        """Loads the SessionData instance from the target session's session_data.yaml file.

        This method is used to load the data layout information of an already existing session. Primarily, this is used
        when preprocessing or processing session data. Depending on the call location (machine), the method
        automatically resolves all necessary paths and creates the necessary directories.

        Notes:
            To create a new session, use the create() method instead.

            Although session_data.yaml is stored both inside raw_data and processed_data subfolders, this method
            always searches only inside the raw_data folder. Storing session data in both folders is only used to ensure
            human experimenters can always trace all data in the lab back to the proper project, animal, and session.

        Args:
            session_path: The path to the root directory of an existing session, e.g.: vrpc_root/project/animal/session.
            on_server: Determines whether the method is used to initialize an existing session on the BioHPC server or
                a non-server machine. Note, non-server runtimes use the same 'root' directory to store raw_data and
                processed_data subfolders. BioHPC server runtimes use different volumes (drives) to store these
                subfolders.
            make_directories: Determines whether to attempt creating any missing directories. Generally, this option
                is safe to be True for all destinations other than some specific BioHPC server runtimes, where some
                data is 'owned' by a general lab account and not the user account. These cases are only present for the
                sl-forgery library and are resolved by that library.

        Returns:
            An initialized SessionData instance for the session whose data is stored at the provided path.

        Raises:
            FileNotFoundError: If the 'session_data.yaml' file is not found under the session_path/raw_data/ subfolder.
        """
        # To properly initialize the SessionData instance, the provided path should contain the raw_data directory
        # with session_data.yaml file.
        session_data_path = session_path.joinpath("raw_data", "session_data.yaml")
        if not session_data_path.exists():
            message = (
                f"Unable to load the SessionData class for the target session: {session_path.stem}. No "
                f"session_data.yaml file was found inside the raw_data folder of the session. This likely "
                f"indicates that the session runtime was interrupted before recording any data, or that the "
                f"session path does not point to a valid session."
            )
            console.error(message=message, error=FileNotFoundError)

        # Loads class data from .yaml file
        instance: SessionData = cls._safe_load(path=session_data_path)

        # The method assumes that the 'donor' .yaml file is always stored inside the raw_data directory of the session
        # to be processed. Since the directory itself might have moved (between or even within the same PC) relative to
        # where it was when the SessionData snapshot was generated, reconfigures the paths to all raw_data files using
        # the root from above.
        local_root = session_path.parents[2]

        # RAW DATA
        new_root = local_root.joinpath(instance.project_name, instance.animal_id, instance.session_name, "raw_data")
        instance.raw_data.resolve_paths(root_directory_path=new_root)

        # Uses the adjusted raw_data section to load the ProjectConfiguration instance. This is used below to resolve
        # all other SessionData sections, as it stores various required root directories.
        project_configuration: ProjectConfiguration = ProjectConfiguration.load(
            project_name=instance.project_name,
            configuration_path=Path(instance.raw_data.project_configuration_path),
        )

        # Resolves the new roots for all sections that use the same root as the raw_data directory:

        # CONFIGURATION
        new_root = local_root.joinpath(instance.project_name, "configuration")
        instance.configuration_data.resolve_paths(
            root_directory_path=new_root,
            experiment_name=instance.experiment_name,
        )

        # DEEPLABCUT
        new_root = local_root.joinpath(instance.project_name, "deeplabcut")
        instance.deeplabcut_data.resolve_paths(root_directory_path=new_root)

        # Resolves the roots for all VRPC-specific sections that use the data from the ProjectConfiguration instance:

        # VRPC PERSISTENT DATA
        new_root = Path(project_configuration.local_root_directory).joinpath(
            instance.project_name, instance.animal_id, "persistent_data"
        )
        instance.vrpc_persistent_data.resolve_paths(root_directory_path=new_root)

        # SCANIMAGEPC PERSISTENT DATA
        new_root = Path(project_configuration.local_mesoscope_directory).joinpath(
            instance.project_name, instance.animal_id, "persistent_data"
        )
        instance.scanimagepc_persistent_data.resolve_paths(root_directory_path=new_root)

        # MESOSCOPE DATA
        instance.mesoscope_data.resolve_paths(
            root_mesoscope_path=Path(project_configuration.local_mesoscope_directory),
            session_name=instance.session_name,
        )

        # DESTINATIONS
        instance.destinations.resolve_paths(
            nas_raw_data_path=Path(project_configuration.local_nas_directory).joinpath(
                instance.project_name, instance.animal_id, instance.session_name, "raw_data"
            ),
            server_raw_data_path=Path(project_configuration.local_server_directory).joinpath(
                instance.project_name, instance.animal_id, instance.session_name, "raw_data"
            ),
            server_configuration_path=Path(project_configuration.local_server_directory).joinpath(
                instance.project_name, "configuration"
            ),
            server_processed_data_path=Path(project_configuration.local_server_working_directory).joinpath(
                instance.project_name, instance.animal_id, instance.session_name, "processed_data"
            ),
        )

        # Resolves the paths to the processed_data directories. The resolution strategy depends on whether the method is
        # called on the VRPC (locally) or the BioHPC server (remotely).
        if not on_server:
            # Local runtimes use the same root session directory for both raw_data and processed_data. This stems from
            # the assumption that most local machines in the lab only use NVME (fast) volumes and, therefore, do not
            # need to separate 'storage' and 'working' data directories.
            new_root = local_root  # Reuses the local root for non-server runtimes

        else:
            # The BioHPC server stores raw_data on slow volume and processed_data on fast (NVME) volume. Therefore, to
            # configure processed_data paths, the method first needs to load the fast volume root path from the
            # project_configuration.yaml file stored in the raw_data folder.
            new_root = Path(project_configuration.server_working_directory)

        # Regenerates the processed_data path depending on the root resolution above
        instance.processed_data.resolve_paths(
            root_directory_path=new_root.joinpath(
                instance.project_name, instance.animal_id, instance.session_name, "processed_data"
            )
        )

        # Generates data directory hierarchies that may be missing on the local machine
        if make_directories:
            instance.raw_data.make_directories()
            instance.configuration_data.make_directories()
            instance.deeplabcut_data.make_directories()
            instance.processed_data.make_directories()
            instance.processed_data.make_directories()

            # Ensures that project configuration and session data classes are present in both raw_data and
            # processed_data directories. This ensures that all data of the session can always be traced to the parent
            # project, animal, and session.
            sh.copy2(
                src=instance.raw_data.session_data_path,
                dst=instance.processed_data.session_data_path,
            )
            sh.copy2(
                src=instance.raw_data.project_configuration_path,
                dst=instance.processed_data.project_configuration_path,
            )

        # Returns the initialized SessionData instance to caller
        return instance

    def _save(self) -> None:
        """Saves the instance data to the 'raw_data' directory and the 'processed_data' directory of the managed session
         as a 'session_data.yaml' file.

        This is used to save the data stored in the instance to disk, so that it can be reused during preprocessing or
        data processing. The method is intended to only be used by the SessionData instance itself during its
        create() method runtime.
        """

        # Generates a copy of the original class to avoid modifying the instance that will be used for further
        # processing
        origin = copy.deepcopy(self)

        # Resets all path fields to null. These fields are not loaded from disk when the instance is loaded, so setting
        # them to null has no negative consequences. Conversely, keeping these fields with Path objects prevents the
        # SessionData instance from being loaded from disk.
        origin.raw_data = None  # type: ignore
        origin.processed_data = None  # type: ignore
        origin.configuration_data = None  # type: ignore
        origin.deeplabcut_data = None  # type: ignore
        origin.vrpc_persistent_data = None  # type: ignore
        origin.scanimagepc_persistent_data = None  # type: ignore
        origin.mesoscope_data = None  # type: ignore
        origin.destinations = None  # type: ignore

        # Saves instance data as a .YAML file
        origin.to_yaml(file_path=self.raw_data.session_data_path)
        origin.to_yaml(file_path=self.processed_data.session_data_path)
